### 42th day
1. leetcode-216:组合之和,通过回溯+剪枝来实现
2. leetcode-125:验证回文串,使用双指针来实现
### 43th day
1. leetcode-567:字符串的排列,使用滑动窗口来实现
2. leetcode230-二叉搜索树中第K小的元素,利用二叉搜索树中序遍历得到的值序列是有序的特点
3. leetcode-343:整数拆分,利用动态规划来实现
### 44th day
1. leetcode-16:最接近的三数之和,利用排序加双指针来实现
2. leetcode-162:寻找峰值,利用迭代爬坡和二分查找
### 45th day
1. leetcode-129:求根节点到叶节点数字之和,深度优先搜索到每个叶子节点,计算每个叶子节点对应的数字,再将每个叶子节点对应的数字加起来
2. leetcode-328:奇偶链表,将奇数节点和偶数节点分别组织成奇数链表和偶数链表,最后将偶数链表连接到奇数链表后面
### 46th day
1. leetcode-25:K 个一组翻转链表,链表分组翻转，记录前一个链表的尾结点,将后一个链表拼接到前一个链表的尾结点后面
2. leetcode-25:K 个一组翻转链表,把矩阵看成若干层，由外层到里层，每一层按照顺时针遍历
### 47th day
1. leetcode-503:下一个更大元素II,利用单调栈来解决，单调栈里面存的是数组下标，数组下标是单调递增的
2. leetcode-413:等差数列划分,利用动态规划来解决
### 48th day
1. leetcode-435:无重叠区间,利用排序加上动态规划来解决
2. leetcode-450:删除二叉搜索树中的节点,利用二叉搜索树中序遍历得到的值序列是有序的,用目标节点的前驱节点或者后继节点来替代目标节点,再向下递归删除前驱节点或者后继节点
3. leetcode-24:两两交换链表中的节点,将每两个节点分为一组，在每一组内进行交换,交换完成之后将上一组的尾结点的next指针指向当前组的头结点
### 49th day
1. leetcode-238:除自身以外数组的乘积,求出每个元素的左侧元素和右侧元素的乘积,那么这个元素除自身以外的乘积就会等于这个元素的左侧乘积乘积右侧乘积
2. leetcode-179:最大数,把数值大的数放在高位,比较输入数组的每个元素的最高位,最高位相同的时候比较次高位，依次类推，完成排序，然后把它们拼接起来
3. leetcode-451:根据字符出现频率排序,先利用哈希表去统计词频，再利用词频去构造优先级队列，最后将优先级队列中的元素弹出来构造答案
### 50th day
1. leetcode-540:有序数组中的单一元素,由于只有一个数出现一次，其他数都是出现两次，则对于出现一次的元素下标x的左边有偶数个元素，所以下标x一定是偶数。因此，可以在偶数下标范围内进行二分查找,找到最小的偶数下标mid,使得nums[mid] != nums[mid+1]
2. leetcode-701:二叉搜索树中的插入操作,将新的节点插入到当前二叉搜索树的其中一个叶子节点上，利用深度优先搜索找到这个叶子节点，然后将新的节点作为这个叶子节点的左子节点或者右子节点
### 51th day
1. leetcode-718:最长重复子数组,利用动态规划和滑动窗口来实现
2. leetcode-116:填充每个节点的下一个右侧节点指针，利用二叉搜索树的层序遍历来实现
### 52th day
1. leetcode-189:轮转数组,数组长度n,向右轮转k个位位置,先将数组翻转,这样尾部的k % n个元素就移动到了数组头部,再翻转[0,k % n-1]和[k % n, n-1]这两个区间的元素就可以得到答案
2. leetcode-61:旋转链表,先得到链表的节点数目，需要向右移动k % n个节点，然后使用快慢指针，快指针移动到链表尾结点时结束，同时使用一个虚节点，虚节点初始时是指向头结点。最后将虚节点的next指针指向slow的下一个节点即可
### 53th day
1. leetcode-135:分发糖果,由于相邻的孩子中,评分高的孩子必须获得更多的糖果,根据这个规则，分别从左向右和从右向左遍历数组，得到每个孩子应该分到的糖果left[i]和right[i],这个孩子实际可以分到的糖果数量为max(left[i],right[i]);对每个孩子进行这样的处理，把每个孩子应该分到的糖果数量加起来就是答案
2. leetcode-378:有序矩阵中第 K 小的元素,利用二分查找来实现
### 54th day
1. leetcode-57:插入区间,找到与需要新插入的区间有交集的区间集合，将这个区间集合里面的所有区间加上新区间合并成为一个大的区间,与区间集合不重叠的区间加上合并后的大区间就是答案
2. leetcode-59:螺旋矩阵 II,将矩阵看成由若干层组成，从外到里填入每一层的元素，直到最内层
### 55th day
1. leetcode-103:二叉树的锯齿形层序遍历,进行层序遍历过程中，使用一个链表来保存这一层的节点值，根据同一层的节点是要求从左向右还是从右向左遍历，将节点值添加到链表的头部还是尾部
2. leetcode-130:被围绕的区域,由于边界上的'o'不会被填充为'x',所以可以以边界上的'o'为起点进行深度优先搜索，找到与这个'o'间接或者直接相连的'o',将其标记，然后再遍历矩阵,矩阵中剩余的'o'需要被置为'x',并将被标记的'o'还原为'o'
### 56th day
1. leetcode-665:非递减数列,遍历数组，找到nums[i] > nums[i+1]的i,当nums[i+1] < nums[i-1]时，将nums[i+1]置为nums[i],其他情况则将nums[i]置为nums[i+1],修改过程中统计修改次数，超过一次则返回false
2. leetcode-763:划分字母区间,使用哈希表统计每个字符最后出现的位置，再遍历一遍数组，对于每个字符在哈希表中得到最后出现的位置，同时维护一个已经枚举过的字符的最后一个位置的最大值，当枚举到的下标等于这个最大值时，就分隔为一个片段,在枚举过程中统计每个片段的长度
3. leetcode-137:只出现一次的数字II,使用哈希表去统计每个数字出现的次数，然后遍历哈希表得到只出现一次的数字
4. leetcode-542:01矩阵
   1. 广度优先搜索:先将所有的0放入到队列中，然后从每个0开始一圈一圈地向1扩散,并且使用一个数组来记录某个位置的1是否被访问过，和使用一个数组来记录距离
   2. 动态规划:使用dp[i][j]来表示matrix[i][j]到最近的0的距离,由于dp[i][j]的状态由上下左右四个状态来决定(dp[i][j-1],dp[i-1][j],dp[i][j+1],dp[i+1][j]),因此状态转移方程为dp[i][j] = 1 + min(dp[i][j-1],dp[i-1][j],dp[i][j+1],dp[i+1][j]),而在处理实际的递推过程中，由于距离(i,j)最近的0在其"左上，右上，左下，右下"四个角，所以可以从这四个角开始递推。同时，由于从四个角开始递推有一些重复计算，可以仅从左下角和右上角开始递推来消除这些重复计算
### 57th day
1. leetcode-1004:最大连续1的个数 III,使用滑动窗口来解决,有left和right两个指针，right指针主动向右移动，每次移动一步，然后判断窗口里面0的数量是不是小于等于0，如果不是，则移动左指针，直到窗口里面的0的数量小于等于k，最大连续区间的长度就是答案
2. leetcode-784:字母大小写全排列,使用回溯处理
3. leetcode-47:全排列II,使用回溯,不做剪枝会导致结果集里面有重复的列表，可以通过剪枝来解决这个问题,办法是在搜索前先对数组进行排序，然后在搜索的时候假如一个下标i，nums[i] == nums[i-1],并且nums[i-1]没有被使用过，i就不再往下搜索
### 58th day
1. leetcode-523:连续的子数组和,使用前缀和和哈希表,当pre[i]-pre[j]为k的倍数时，pre[i]和pre[j]除以k的余数是相同的,因此只需要计算每个前缀和除以k的余数就可以，然后使用哈希表来记录每个余数第一次出现的下标,然后遍历数组，对于每个元素i求得前缀和pre[i],再用pre[i] % 6求得余数,最后再去哈希表查找有没有相同余数的前缀和，当存储并且子数组长度大于等于2就返回true，其他返回false
2. leetcode-1208:尽可能使字符串相等,假定字符串origin和target的长度均为n，对于长度0<=i<=n,将origin[i]转变为target[i]的开销为abs(origin[i]-target[i]),因此可以创建一个长度为n的数组diff,其中diff[i]=abs(origin[i]-target[i])。这个问题转化为了计算数组diff的元素和不超过maxCost的最长子数组的长度,由于diff的每个元素都是非负的,因此可以使用滑动窗口的方法得到元素和不超过maxCost的最长子数组的长度
### 59th day
1. leetcode-713:乘积小于 K 的子数组,使用滑动窗口的方法来解决:使用left和right两个指针，初始值都是指向数组的第一个元素，同时使用prod来记录窗口内元素的乘积。right指针向右边移动，当prod >= k时，就移动left指针，直到prod<k,此时乘积小于k的子数组的数目为right-left+1
2. leetcode-316:去除重复字母,使用贪心+单调栈来实现
### 60th day
1. leetcode-77:组合,使用回溯的模板解决
2. leetcode-350:两个数组的交集II,使用哈希表存储数组nums1中每个数字出现的次数，然后枚举数组nums2中的每个元素，在哈希表中查找这个元素，存在的话添加到答案中，然后哈希表中这个数字出现的次数减去1，为了降低空间复杂度，先遍历较短的数组并在哈希表中维护每个数字出现的次数，再遍历较长的数组
3. leetcode-151:颠倒字符串中的单词
   1. 先去除头尾和中间无效的空白字符，再翻转整个字符串，最后翻转每个单词
   2. 利用双端队列支持头部插入元素的方法，从前往后处理字符串中的每个单词，将单词添加到双端队列的头部，最后将双端队列转换成字符串
### 61th day
1. leetcode-695:岛屿的最大面积,使用深度优先搜索来实现:以网格里面的1位起点进行深度优先搜索,在搜索过程中，每个搜索到的1都会被标记为0，并且统计每个1在四个方向上相邻的1的数量，这样就求得每个连通形状的面积，最后得到最大面积
2. leetcode-90:子集II,新增回溯的解法
### 62th day
1. leetcode-60:排列序列,回溯和剪枝来实现，不用输出全排列，取第k个，而是在深度优先搜索过程中，利用未选择的数可以产生多少排列来做剪枝,最后得到第k个排列
2. leetcode-376:摆动序列,使用动态规划来解决
### 63th day
1. leetcode-1143:最长公共子序列,利用动态规划来就解决
2. leetcode-518:零钱兑换II,利用动态规划来解决
### 64th day
1. leetcode-513:找树左下角的值,使用层序遍历，使用一个变量ans来保存每层的第一个节点，最后这个变量对应的节点就是最左边的节点
2. leetcode-524:通过删除字母匹配到字典里最长单词
   1. 排序+双指针+贪心:先对字典进行排序，然后再利用双指针在dict中找到第一个是字符串s的子序列的字符串
   2. 动态规划
### 65th day
1. leetcode-115:不同的子序列,利用动态规划来解决
2. leetcode-740:删除并获得点数,利用动态规划来解决，类似于打家劫舍
### 66th day
1. leetcode-127:
   1. 构建图+广度优先遍历:单词接龙,利用给定的单词列表构建无向图，然后在图里面找最短路径
   2. 双向广度优先遍历:已知起点和终点，可以分别从起点和终点执行广度优先遍历，直到遍历的部分有交集，这样单词的搜索量会更小
2. leetcode-377:组合总和Ⅳ,利用动态规划来解决
### 67th day
1. leetcode-187:重复的DNA序列,使用哈希表+滑动窗口实现
2. leetcode-1104:二叉树寻路,由于从根节点到任意一层都是满二叉树，我们可以先确定label所在的层级，就可以计算出当前层起始节点值和结束节点值。再利用每层节点数量翻倍和隔层奇偶性翻转，就可以寻找出上一层的节点的下标(每层下标从左向右计算，并从1开始)，直到构造出答案(到根节点)
3. leetcode-1011:在 D 天内送达包裹的能力,利用二分查找来实现
### 68th day
1. leetcode-1190:反转每对括号间的子串,使用双端队列来实现
2. leetcode-841:钥匙和房间,利用深度优先搜索来实现
### 69th day
1. leetcode-433:最小基因变化,使用BFS来实现，类似于leetcode-127题
2. leetcode-654:最大二叉树,利用递归创建
### 70th day
1. leetcode-881:救生艇,使用贪心来实现
2. leetcode-334:递增的三元子序列
   1. 通过遍历数组，得到每个元素左边的最小值和右边的最大值，假如有一个下标i满足leftMin[i] < nums[i] < rightMax[i]这个条件，则这个数组存在递增的三元子序列
   2. 使用贪心思想来实现
### 71th day
1. leetcode-1305:两棵二叉搜索树中的所有元素,二叉搜索树的中序遍历结果是一个有序数组，因此可以中序遍历这两棵二叉搜索树，得到两个有序数组，然后使用双指针合并这两个有序数组
2. leetcode-978:最长湍流子数组
   1. 使用滑动窗口来实现
   2. 使用动态规划来实现