### 42th day
1. leetcode-216:组合之和,通过回溯+剪枝来实现
2. leetcode-125:验证回文串,使用双指针来实现
### 43th day
1. leetcode-567:字符串的排列,使用滑动窗口来实现
2. leetcode230-二叉搜索树中第K小的元素,利用二叉搜索树中序遍历得到的值序列是有序的特点
3. leetcode-343:整数拆分,利用动态规划来实现
### 44th day
1. leetcode-16:最接近的三数之和,利用排序加双指针来实现
2. leetcode-162:寻找峰值,利用迭代爬坡和二分查找
### 45th day
1. leetcode-129:求根节点到叶节点数字之和,深度优先搜索到每个叶子节点,计算每个叶子节点对应的数字,再将每个叶子节点对应的数字加起来
2. leetcode-328:奇偶链表,将奇数节点和偶数节点分别组织成奇数链表和偶数链表,最后将偶数链表连接到奇数链表后面
### 46th day
1. leetcode-25:K 个一组翻转链表,链表分组翻转，记录前一个链表的尾结点,将后一个链表拼接到前一个链表的尾结点后面
2. leetcode-25:K 个一组翻转链表,把矩阵看成若干层，由外层到里层，每一层按照顺时针遍历
### 47th day
1. leetcode-503:下一个更大元素II,利用单调栈来解决，单调栈里面存的是数组下标，数组下标是单调递增的
2. leetcode-413:等差数列划分,利用动态规划来解决
### 48th day
1. leetcode-435:无重叠区间,利用排序加上动态规划来解决
2. leetcode-450:删除二叉搜索树中的节点,利用二叉搜索树中序遍历得到的值序列是有序的,用目标节点的前驱节点或者后继节点来替代目标节点,再向下递归删除前驱节点或者后继节点
3. leetcode-24:两两交换链表中的节点,将每两个节点分为一组，在每一组内进行交换,交换完成之后将上一组的尾结点的next指针指向当前组的头结点
### 49th day
1. leetcode-238:除自身以外数组的乘积,求出每个元素的左侧元素和右侧元素的乘积,那么这个元素除自身以外的乘积就会等于这个元素的左侧乘积乘积右侧乘积
2. leetcode-179:最大数,把数值大的数放在高位,比较输入数组的每个元素的最高位,最高位相同的时候比较次高位，依次类推，完成排序，然后把它们拼接起来
3. leetcode-451:根据字符出现频率排序,先利用哈希表去统计词频，再利用词频去构造优先级队列，最后将优先级队列中的元素弹出来构造答案
### 50th day
1. leetcode-540:有序数组中的单一元素,由于只有一个数出现一次，其他数都是出现两次，则对于出现一次的元素下标x的左边有偶数个元素，所以下标x一定是偶数。因此，可以在偶数下标范围内进行二分查找,找到最小的偶数下标mid,使得nums[mid] != nums[mid+1]
2. leetcode-701:二叉搜索树中的插入操作,将新的节点插入到当前二叉搜索树的其中一个叶子节点上，利用深度优先搜索找到这个叶子节点，然后将新的节点作为这个叶子节点的左子节点或者右子节点
### 51th day
1. leetcode-718:最长重复子数组,利用动态规划和滑动窗口来实现
2. leetcode-116:填充每个节点的下一个右侧节点指针，利用二叉搜索树的层序遍历来实现
### 52th day
1. leetcode-189:轮转数组,数组长度n,向右轮转k个位位置,先将数组翻转,这样尾部的k % n个元素就移动到了数组头部,再翻转[0,k % n-1]和[k % n, n-1]这两个区间的元素就可以得到答案
2. leetcode-61:旋转链表,先得到链表的节点数目，需要向右移动k % n个节点，然后使用快慢指针，快指针移动到链表尾结点时结束，同时使用一个虚节点，虚节点初始时是指向头结点。最后将虚节点的next指针指向slow的下一个节点即可
### 53th day
1. leetcode-135:分发糖果,由于相邻的孩子中,评分高的孩子必须获得更多的糖果,根据这个规则，分别从左向右和从右向左遍历数组，得到每个孩子应该分到的糖果left[i]和right[i],这个孩子实际可以分到的糖果数量为max(left[i],right[i]);对每个孩子进行这样的处理，把每个孩子应该分到的糖果数量加起来就是答案
2. leetcode-378:有序矩阵中第 K 小的元素,利用二分查找来实现
### 54th day
1. leetcode-57:插入区间,找到与需要新插入的区间有交集的区间集合，将这个区间集合里面的所有区间加上新区间合并成为一个大的区间,与区间集合不重叠的区间加上合并后的大区间就是答案
2. leetcode-59:螺旋矩阵 II,将矩阵看成由若干层组成，从外到里填入每一层的元素，直到最内层
### 55th day
1. leetcode-103:二叉树的锯齿形层序遍历,进行层序遍历过程中，使用一个链表来保存这一层的节点值，根据同一层的节点是要求从左向右还是从右向左遍历，将节点值添加到链表的头部还是尾部
2. leetcode-130:被围绕的区域,由于边界上的'o'不会被填充为'x',所以可以以边界上的'o'为起点进行深度优先搜索，找到与这个'o'间接或者直接相连的'o',将其标记，然后再遍历矩阵,矩阵中剩余的'o'需要被置为'x',并将被标记的'o'还原为'o'
### 56th day
1. leetcode-665:非递减数列,遍历数组，找到nums[i] > nums[i+1]的i,当nums[i+1] < nums[i-1]时，将nums[i+1]置为nums[i],其他情况则将nums[i]置为nums[i+1],修改过程中统计修改次数，超过一次则返回false
2. leetcode-763:划分字母区间,使用哈希表统计每个字符最后出现的位置，再遍历一遍数组，对于每个字符在哈希表中得到最后出现的位置，同时维护一个已经枚举过的字符的最后一个位置的最大值，当枚举到的下标等于这个最大值时，就分隔为一个片段,在枚举过程中统计每个片段的长度
3. leetcode-137:只出现一次的数字II,使用哈希表去统计每个数字出现的次数，然后遍历哈希表得到只出现一次的数字
4. leetcode-542:01矩阵
   1. 广度优先搜索:先将所有的0放入到队列中，然后从每个0开始一圈一圈地向1扩散,并且使用一个数组来记录某个位置的1是否被访问过，和使用一个数组来记录距离
   2. 动态规划:使用dp[i][j]来表示matrix[i][j]到最近的0的距离,由于dp[i][j]的状态由上下左右四个状态来决定(dp[i][j-1],dp[i-1][j],dp[i][j+1],dp[i+1][j]),因此状态转移方程为dp[i][j] = 1 + min(dp[i][j-1],dp[i-1][j],dp[i][j+1],dp[i+1][j]),而在处理实际的递推过程中，由于距离(i,j)最近的0在其"左上，右上，左下，右下"四个角，所以可以从这四个角开始递推。同时，由于从四个角开始递推有一些重复计算，可以仅从左下角和右上角开始递推来消除这些重复计算
### 57th day
1. leetcode-1004:最大连续1的个数 III,使用滑动窗口来解决,有left和right两个指针，right指针主动向右移动，每次移动一步，然后判断窗口里面0的数量是不是小于等于0，如果不是，则移动左指针，直到窗口里面的0的数量小于等于k，最大连续区间的长度就是答案
2. leetcode-784:字母大小写全排列,使用回溯处理
3. leetcode-47:全排列II,使用回溯,不做剪枝会导致结果集里面有重复的列表，可以通过剪枝来解决这个问题,办法是在搜索前先对数组进行排序，然后在搜索的时候假如一个下标i，nums[i] == nums[i-1],并且nums[i-1]没有被使用过，i就不再往下搜索
### 58th day
1. leetcode-523:连续的子数组和,使用前缀和和哈希表,当pre[i]-pre[j]为k的倍数时，pre[i]和pre[j]除以k的余数是相同的,因此只需要计算每个前缀和除以k的余数就可以，然后使用哈希表来记录每个余数第一次出现的下标,然后遍历数组，对于每个元素i求得前缀和pre[i],再用pre[i] % 6求得余数,最后再去哈希表查找有没有相同余数的前缀和，当存储并且子数组长度大于等于2就返回true，其他返回false
2. leetcode-1208:尽可能使字符串相等,假定字符串origin和target的长度均为n，对于长度0<=i<=n,将origin[i]转变为target[i]的开销为abs(origin[i]-target[i]),因此可以创建一个长度为n的数组diff,其中diff[i]=abs(origin[i]-target[i])。这个问题转化为了计算数组diff的元素和不超过maxCost的最长子数组的长度,由于diff的每个元素都是非负的,因此可以使用滑动窗口的方法得到元素和不超过maxCost的最长子数组的长度
### 59th day
1. leetcode-713:乘积小于 K 的子数组,使用滑动窗口的方法来解决:使用left和right两个指针，初始值都是指向数组的第一个元素，同时使用prod来记录窗口内元素的乘积。right指针向右边移动，当prod >= k时，就移动left指针，直到prod<k,此时乘积小于k的子数组的数目为right-left+1
2. leetcode-316:去除重复字母,使用贪心+单调栈来实现
### 60th day
1. leetcode-77:组合,使用回溯的模板解决
2. leetcode-350:两个数组的交集II,使用哈希表存储数组nums1中每个数字出现的次数，然后枚举数组nums2中的每个元素，在哈希表中查找这个元素，存在的话添加到答案中，然后哈希表中这个数字出现的次数减去1，为了降低空间复杂度，先遍历较短的数组并在哈希表中维护每个数字出现的次数，再遍历较长的数组
3. leetcode-151:颠倒字符串中的单词
   1. 先去除头尾和中间无效的空白字符，再翻转整个字符串，最后翻转每个单词
   2. 利用双端队列支持头部插入元素的方法，从前往后处理字符串中的每个单词，将单词添加到双端队列的头部，最后将双端队列转换成字符串
### 61th day
1. leetcode-695:岛屿的最大面积,使用深度优先搜索来实现:以网格里面的1位起点进行深度优先搜索,在搜索过程中，每个搜索到的1都会被标记为0，并且统计每个1在四个方向上相邻的1的数量，这样就求得每个连通形状的面积，最后得到最大面积
2. leetcode-90:子集II,新增回溯的解法
### 62th day
1. leetcode-60:排列序列,回溯和剪枝来实现，不用输出全排列，取第k个，而是在深度优先搜索过程中，利用未选择的数可以产生多少排列来做剪枝,最后得到第k个排列
2. leetcode-376:摆动序列,使用动态规划来解决
### 63th day
1. leetcode-1143:最长公共子序列,利用动态规划来就解决
2. leetcode-518:零钱兑换II,利用动态规划来解决
### 64th day
1. leetcode-513:找树左下角的值,使用层序遍历，使用一个变量ans来保存每层的第一个节点，最后这个变量对应的节点就是最左边的节点
2. leetcode-524:通过删除字母匹配到字典里最长单词
   1. 排序+双指针+贪心:先对字典进行排序，然后再利用双指针在dict中找到第一个是字符串s的子序列的字符串
   2. 动态规划
### 65th day
1. leetcode-115:不同的子序列,利用动态规划来解决
2. leetcode-740:删除并获得点数,利用动态规划来解决，类似于打家劫舍
### 66th day
1. leetcode-127:
   1. 构建图+广度优先遍历:单词接龙,利用给定的单词列表构建无向图，然后在图里面找最短路径
   2. 双向广度优先遍历:已知起点和终点，可以分别从起点和终点执行广度优先遍历，直到遍历的部分有交集，这样单词的搜索量会更小
2. leetcode-377:组合总和Ⅳ,利用动态规划来解决
### 67th day
1. leetcode-187:重复的DNA序列,使用哈希表+滑动窗口实现
2. leetcode-1104:二叉树寻路,由于从根节点到任意一层都是满二叉树，我们可以先确定label所在的层级，就可以计算出当前层起始节点值和结束节点值。再利用每层节点数量翻倍和隔层奇偶性翻转，就可以寻找出上一层的节点的下标(每层下标从左向右计算，并从1开始)，直到构造出答案(到根节点)
3. leetcode-1011:在 D 天内送达包裹的能力,利用二分查找来实现
### 68th day
1. leetcode-1190:反转每对括号间的子串,使用双端队列来实现
2. leetcode-841:钥匙和房间,利用深度优先搜索来实现
### 69th day
1. leetcode-433:最小基因变化,使用BFS来实现，类似于leetcode-127题
2. leetcode-654:最大二叉树,利用递归创建
### 70th day
1. leetcode-881:救生艇,使用贪心来实现
2. leetcode-334:递增的三元子序列
   1. 通过遍历数组，得到每个元素左边的最小值和右边的最大值，假如有一个下标i满足leftMin[i] < nums[i] < rightMax[i]这个条件，则这个数组存在递增的三元子序列
   2. 使用贪心思想来实现
### 71th day
1. leetcode-1305:两棵二叉搜索树中的所有元素,二叉搜索树的中序遍历结果是一个有序数组，因此可以中序遍历这两棵二叉搜索树，得到两个有序数组，然后使用双指针合并这两个有序数组
2. leetcode-978:最长湍流子数组
   1. 使用滑动窗口来实现
   2. 使用动态规划来实现
### 72th day
1. leetcode-436:寻找右区间
   1. 使用两个数组分别保存每个区间的左端点和右端点，再对这两个数组从小达到排序，最后用双指针找到每个区间对应的右区间
   2. 对每个区间的左端点排序，并且使用一个数组startIntervals保存每个左端点所在的区间的下标i。然后枚举每个区间的右端点，利用二分查找在左端点排序后的数组中找到大于等于右端点的最小值val即可,此时区间i对应的右侧区间的下标就是val对应的索引
2. leetcode-491:递增子序列,回溯+剪枝
3. leetcode-863:二叉树中所有距离为 K 的结点,先维护所有节点的父节点的哈希表，然后以target节点为根节点，进行深度优先搜索，在搜索过程中，除了搜索左右子节点，还可以顺着父节点向上搜索，找到所有深度为k的节点
### 73th day
1. leetcode-498:对角线遍历,使用模拟的方法来实现
2. leetcode-845:数组中的最长山脉，按照山脉数组的定义:左侧山脚到山顶的序列是单调递增的，从山顶到右侧山脚是单调递减的。因此可以遍历数组中的每个元素作为山顶可以向左右两侧可以扩展的元素数目。再得到每个元素向左和向右扩展元素数目之和，最后得到最长的山脉数组的长度
### 74th day
1. leetcode-690:员工的重要性,先维护雇员id和雇员映射的哈希表，然后进行深度优先搜索，根据id找到对应的雇员，将这个雇员的重要性加到总和，然后找到这个雇员的下属进行深度优先遍历，直到所有下属遍历完毕，此时total值就是给定员工及其下属的重要性之和
2. leetcode-1020:飞地的数量,以网格边界上的每个陆地单元格为起点进行深度优先搜索，这个过程完成以后，所有和网格边界相连的陆地单元格都被访问到。然后遍历整个网格，如果一个陆地单元格没有被访问到，则这个陆地单元格不和网格的边界相连，则是飞地
### 75th day
1. leetcode-475:供暖期,使用排序和二分查找来实现
2. leetcode-397:整数替换,使用BFS,同时为了避免重复处理某些数，使用哈希表进行记忆化处理
### 76th day
1. leetcode-1014:最佳观光组合,由于res = values[i] + values[j]+i-j,对于每一个j，它的值values[j]和j是固定的，所以values[j]-j也是固定的。因此，要得到res的最大值，就是求values[i]+i的最大值。可以使用一个变量preMax来存储每个j前面的i(i<j)的values[i]+i的最大值
2. leetcode-1706:球会落何处,对于每个球，从上往下判断球位置的移动方向。在对应的位置，如果挡板向右偏，则向右移动，如果挡板向左偏，则向左移动。若移动过程中碰到挡板或者V型，则球会停止移动，卡在箱子里
3. leetcode-386:字典序排数,使用DFS是来实现，为了实现严格的O(1)时间复杂度,使用迭代来实现DFS
4. leetcode-525:连续数组,将数组中值为0的元素变为-1，这个问题就能转化为 求最长一段区间和为0的子数组。就可以使用前缀和+哈希表。哈希表里面维护的是某个前缀和出现的最小下标
5. leetcode-675:为高尔夫比赛砍树,利用BFS来解决
### 77th day
1. leetcode-904:水果成篮,使用滑动窗口来实现
2. leetcode-424:替换后的最长重复字符,使用滑动窗口来实现
3. leetcode-965:单值二叉树,使用深度优先搜索实现
### 78th day
1. leetcode-1423:可获得的最大点数,使用固定长度的滑动窗口来实现
2. leetcode-1162:地图分析,使用广度优先遍历来实现
### 79th day
1. leetcode-1049:最后一块石头的重量 II,可以将这个问题转换为一个完全背包问题，类似于leetcode-494
2. leetcode-331:验证二叉树的前序序列化,二叉树可以看成是有向图，一条有向边带来一个出度和一个入度，二叉树的总出度等于总入度。
3. leetcode-945:使数组唯一的最小增量,先对数组排序，然后遍历数组，如果当前元素小于等于它前一个元素，则将其变为前一个数加1
### 80th day
1. leetcode-1894:找到需要补充粉笔的学生编号,利用前缀和+二分查找来实现
2. leetcode-1248:统计「优美子数组」
   1. 使用滑动窗口实现
   2. 使用前缀和来实现  
3. leetcode-877:石子游戏,使用动态规划来实现
### 81th day
1. leetcode-365:水壶问题,使用广度优先搜索来实现
2. leetcode-456:132模式,使用单调栈来实现
3. leetcode-767:重构字符串,使用基于最大堆的贪心来实现
### 82th day
1. leetcode-395:至少有 K 个重复字符的最长子串,使用滑动窗口来实现
2. leetcode-875:爱吃香蕉的珂珂,使用二分查找来实现
### 83th day
1. leetcode-931:下降路径最小和,使用动态规划来实现
2. leetcode-396:旋转函数,使用滑动窗口+前缀和来实现
3. leetcode-673:最长递增子序列的个数,使用动态规划来实现
### 84th day
1. leetcode-554:砖墙,使用哈希表来实现
2. leetcode-220:存在重复元素 III,利用桶排序思想来实现
3. leetcode-838:推多米诺,使用BFS来实现
### 85th day
1. leetcode-1438:绝对差不超过限制的最长连续子数组,使用滑动窗口+单调队列,使用一个单调递增的队列维护当前区间的最小值，同时使用一个单调递减的队列维护当前区间的最大值。然后计算两个队列的队首的差值，就可以知道当前区间是否满足条件
2. leetcode-611:有效三角形的个数,使用排序+双指针来实现
### 86th day
1. leetcode-368:最大整除子集,使用动态规划来实现
### 87th day
1. leetcode-1823:找出游戏的获胜者,使用队列模拟
2. leetcode-846:一手顺子,使用哈希表+优先队列(小根堆)来实现
3. leetcode-983:最低票价,使用动态规划来实现
### 88th day
1. leetcode-1034:边界着色,使用深度优先搜索来实现
2. leetcode-275:H指数II,使用二分查找来实现
### 89th day
1. leetcode-120:三角形最小路径和,使用动态规划来实现
2. leetcode-1035:不相交的线,转化为最长公共子序列长度,使用动态规划来解决
### 90th day
1. leetcode-419:甲板上的战舰,使用枚举起点的方法来实现
2. leetcode-669:修剪二叉搜索树,使用DFS来实现
3. leetcode-1405:最长快乐字符串,使用贪心思想+优先级队列来实现
### 91th day
1. leetcode-373:查找和最小的 K 对数字,使用优先队列来实现
2. leetcode-861:翻转矩阵后的得分,使用贪心思想来实现
### 92th day
1. leetcode-1219:黄金矿工,使用回溯算法来实现
2. leetcode-1091:二进制矩阵中的最短路径,最短路径问题使用广度优先遍历来实现
### 93th day
1. leetcode-974:和可被K整除的子数组,使用前缀和+哈希表来实现
2. leetcode-1482:制作m束花所需的最少天数,使用二分查找来实现
### 94th day
1. leetcode-954:二倍数对数组,使用哈希表+排序来实现
### 95th day
1. leetcode-1609:奇偶树,使用BFS来实现
2. leetcode-986:区间列表的交集,使用双指针来实现
3. leetcode-1254:统计封闭岛屿的数目,使用深度优先搜索来实现
### 96th day
1. leetcode-2038:如果相邻两个颜色均相同则删除当前颜色,使用贪心来实现
2. leetcode-1249:移除无效的括号,使用栈+哈希表来实现
### 97th day
1. leetcode-1877:数组中最大数对和的最小值,使用排序+贪心来实现
2. leetcode-814:二叉树剪枝,使用深度优先搜索来实现
3. leetcode-473:火柴拼正方形,使用回溯来实现
### 98th day
1. leetcode-313:超级丑数,使用优先队列多路归并来实现
2. leetcode-890:查找和替换模式,使用哈希表来实现
3. leetcode-719:找出第 K 小的数对距离,使用排序+二分查找+双指针来实现
### 99th day
1. leetcode-921:使括号有效的最少添加,使用平衡法来实现
2. leetcode-1024:视频拼接,使用动态规划来实现
### 100th day(300题)
1. leetcode-1111:有效括号的嵌套深度,使用栈进行括号匹配
2. leetcode-662:二叉树最大宽度,使用BFS层级遍历二叉树，同时使用一个队列记录节点的位置索引
