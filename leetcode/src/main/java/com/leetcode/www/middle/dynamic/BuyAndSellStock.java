package com.leetcode.www.middle.dynamic;

/**
 * 给定一个整数数组prices，其中第prices[i]表示第i天的股票价格。设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票)
 * 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
 *
 */
public class BuyAndSellStock {

    /**
     * 解法:动态规划
     *      1. 状态表示:f(i)表示第i天结束之后的累计最大收益，由于我们最多只能同时持有一支股票，并且卖出股票后有冷冻期的限制。所以状态可能有以下三种情况
     *          1. f[i][0]:表示我们目前持有一支股票对应的累计最大收益
     *          2. f[i][1]:表示我们目前不持有股票，并且处于冷冻期，对应的累计最大收益。处于冷冻期是表示第i天结束后的状态。也就是说如果第i天结束之后处于冷冻期就表示
     *                     第i天卖出了股票，第i+1天不能买入股票
     *          3. f[i][2]:表示我们目前不持有股票，并且不处于冷冻期，对应的累计最大收益
     *       2. 状态转移方程
     *          f[i][0] = max(f[i-1][0], f[i-1][2]-prices[i])。第i天结束后要持有股票有两种情况:一是第i-1天持有股票，第i天不卖出。二是第i-1天不持有股票且不在冷冻期
     *                    然后第i天买入
     *          f[i][1] = f[i-1][0] + prices[i]。第i天结束后要处于冷冻状态，需要第i天卖出了股票，那意味着第i-1天持有股票
     *          f[i][2] = max(f[i-1][1],f[i-1][2]).第i天结束后不持有任何股票，并且不处于冷冻状态。那就说明第i天没有做任何操作。
     *       3. 边界条件:在第0天如果持有股票，那就是在第0天买入的，则收益是-prices[0];假如第0天不持有股票，那么最大收益就是0
     *       4. 要求最大收益，假如最后一天还持有股票，此条件求出的最大收益肯定不是最大的，因此maxProfit = max(f[n-1][1], f[n-1][2])
     * @param prices
     * @return
     */
    public int solution(int[] prices){

        if (prices.length == 0){
            return 0;
        }

        int length = prices.length;
        int[][] dp = new int[length][3];
        dp[0][0] = -prices[0];
        for (int i = 1; i < length; i++){
            dp[1][0] = Math.max(dp[i-1][0], dp[i-1][2] - prices[i]);
            dp[1][1] = dp[i-1][0] + prices[i];
            dp[1][2] = Math.max(dp[i-1][1], dp[i-1][2]);
        }

        return Math.max(dp[length - 1][1], dp[length-1][2]);
    }
}
